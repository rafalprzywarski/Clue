(ns clue.core)

(def not (fn [x] (if x false true)))

(def cons lua/clue.cons)
(def conj lua/clue.conj)
(def list lua/clue.list)
(def vector lua/clue.vector)
(def seq lua/clue.seq)
(def vec lua/clue.vec)
(def first (fn [seq] (. seq (first))))
(def rest lua/clue.rest)
(def next (fn [seq] (. seq (next))))
(def pr-str lua/clue.pr_str)
(def str lua/clue.str)
(def + lua/clue.op_add)
(def - lua/clue.op_sub)
(def * lua/clue.op_mul)
(def / lua/clue.op_div)
(def % lua/clue.op_mod)
(def = lua/clue.equals)

(def assoc (fn [map k v] (. map (assoc k v))))

(def nil? (fn [x] (= x nil)))

(def spread (fn
    [args]
    (if (nil? args)
        nil
        (if (nil? (next args))
            (seq (first args))
            (cons (first args) (spread (next args)))))))

(def list* (fn
    ([args] (seq args))
    ([a args] (cons a args))
    ([a b args] (cons a (cons b args)))
    ([a b c args] (cons a (cons b (cons c args))))
    ([a b c d & more] (cons a (cons b (cons c (cons d (spread more))))))))

(def apply (fn
    ([f args] ((. lua/clue apply_to) f (seq args)))
    ([f x args] ((. lua/clue apply_to) f (list* x args)))
    ([f x y args] ((. lua/clue apply_to) f (list* x y args)))
    ([f x y z args] ((. lua/clue apply_to) f (list* x y z args)))
    ([f a b c d & args] ((. lua/clue apply_to) f (cons a (cons b (cons c (cons d (spread args)))))))))

(def not= (fn [& args] (not (apply = args))))

(def ^:macro lazy-seq (fn [body]
    (list (list '. 'lua/clue 'lazy_seq) (list 'fn [] body))))

(def ^:macro declare (fn [sym] (list 'def sym nil)))

(def cat- (fn [xys zs]
    (lazy-seq
        (let [xys (seq xys)]
            (if xys
                (cons (first xys) (cat- (rest xys) zs))
                (if zs
                    (cat- (first zs) (next zs))))))))

(def concat (fn
    ([] (lazy-seq nil))
    ([x] (lazy-seq x))
    ([x y]
        (lazy-seq
            (let [s (seq x)]
                (if s
                    (cons (first s) (concat (rest s) y))
                    y))))
    ([x y & zs]
        (cat- (concat x y) zs))))

(def with-meta (fn [obj m] (. obj (with_meta m))))
(def meta (fn [obj] (. obj meta)))

(def type (fn [obj] (lua/clue.type obj)))
(def instance? (fn [cls, obj] (= cls (type obj))))

(def var? (fn [obj] (instance? lua/clue.Var obj)))
(def var-get (fn [v] (. v (get))))

(def dec (fn [n] (- n 1)))
(def inc (fn [n] (+ n 1)))
(def zero? (fn [n] (= n 0)))

(def take (
    fn [n coll]
    (cons
        (first coll)
        (if (not= n 1) (lazy-seq (take (dec n) (rest coll)))))))

(def take-while
    (fn [pred coll]
        (lazy-seq
            (let [s (seq coll)]
                (if s
                    (if (pred (first s))
                        (cons (first s) (take-while pred (rest s)))))))))

(def drop
    (fn [n coll]
        (if (zero? n) coll (drop (dec n) (lazy-seq (rest coll))))))

(def map (fn [f coll]
    (lazy-seq
        (let [s (seq coll)]
            (if s
                (cons (f (first s)) (map f (rest s))))))))

(def pr (fn [val] (lua/print (pr-str val))))
