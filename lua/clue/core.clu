(ns clue.core)

(def not (fn [x] (if x false true)))

(def cons lua/clue.cons)
(def conj lua/clue.conj)
(def list lua/clue.list)
(def vector lua/clue.vector)
(def seq lua/clue.seq)
(def vec lua/clue.vec)
(def first (fn [seq] (. seq (first))))
(def rest lua/clue.rest)
(def next (fn [seq] (. seq (next))))
(def pr-str lua/clue.pr_str)
(def str lua/clue.str)
(def + lua/clue.op_add)
(def - lua/clue.op_sub)
(def * lua/clue.op_mul)
(def / lua/clue.op_div)
(def % lua/clue.op_mod)
(def = lua/clue.equals)

(def ^:macro defn (fn [name & body] (list 'def name (cons 'fn body))))

(defn assoc [map k v] (. map (assoc k v)))

(defn nil? [x] (= x nil))

(defn spread
    [args]
    (if (nil? args)
        nil
        (if (nil? (next args))
            (seq (first args))
            (cons (first args) (spread (next args))))))

(defn list*
    ([args] (seq args))
    ([a args] (cons a args))
    ([a b args] (cons a (cons b args)))
    ([a b c args] (cons a (cons b (cons c args))))
    ([a b c d & more] (cons a (cons b (cons c (cons d (spread more)))))))

(defn apply
    ([f args] ((. lua/clue apply_to) f (seq args)))
    ([f x args] ((. lua/clue apply_to) f (list* x args)))
    ([f x y args] ((. lua/clue apply_to) f (list* x y args)))
    ([f x y z args] ((. lua/clue apply_to) f (list* x y z args)))
    ([f a b c d & args] ((. lua/clue apply_to) f (cons a (cons b (cons c (cons d (spread args))))))))

(defn not= [& args] (not (apply = args)))

(defn ^:macro lazy-seq [body]
    (list (list '. 'lua/clue 'lazy_seq) (list 'fn [] body)))

(defn ^:macro declare [sym] (list 'def sym nil))

(defn cat- [xys zs]
    (lazy-seq
        (let [xys (seq xys)]
            (if xys
                (cons (first xys) (cat- (rest xys) zs))
                (if zs
                    (cat- (first zs) (next zs)))))))

(defn concat
    ([] (lazy-seq nil))
    ([x] (lazy-seq x))
    ([x y]
        (lazy-seq
            (let [s (seq x)]
                (if s
                    (cons (first s) (concat (rest s) y))
                    y))))
    ([x y & zs]
        (cat- (concat x y) zs)))

(defn with-meta [obj m] (. obj (with_meta m)))
(defn meta [obj] (. obj meta))

(defn type [obj] (lua/clue.type obj))
(defn instance? [cls, obj] (= cls (type obj)))

(defn var? [obj] (instance? lua/clue.Var obj))
(defn var-get [v] (. v (get)))

(defn dec [n] (- n 1))
(defn inc [n] (+ n 1))
(defn zero? [n] (= n 0))

(defn take [n coll]
    (cons
        (first coll)
        (if (not= n 1) (lazy-seq (take (dec n) (rest coll))))))

(defn take-while [pred coll]
    (lazy-seq
        (let [s (seq coll)]
            (if s
                (if (pred (first s))
                    (cons (first s) (take-while pred (rest s))))))))

(defn drop [n coll]
    (if (zero? n) coll (drop (dec n) (lazy-seq (rest coll)))))

(defn map [f coll]
    (lazy-seq
        (let [s (seq coll)]
            (if s
                (cons (f (first s)) (map f (rest s)))))))

(defn pr [val] (lua/print (pr-str val)))
